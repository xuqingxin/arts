# ARTS Week 2

## Algorithm
[Add Two Numbers](https://github.com/xuqingxin/leetcode/blob/master/Algorithms/0002-Add.Two.Numbers.md)

[Longest Substring Without Repeating Characters](https://github.com/xuqingxin/leetcode/blob/master/Algorithms/0002-Add.Two.Numbers.md)


## Review
### 构建单体系统的三个理由 —— 是的，我是认真的
原文连接：[
3 Reasons to Build Monolithic Systems](
https://medium.com/design-and-tech-co/3-reasons-to-build-monolithic-systems-6f06be80cdfa?sk=966990bbe8015860282a2a84742b8158)

在这篇文章中，作者提了3个理由来说明为什么要构建单体系统而不是目前流行的微服务系统。

### 1. 构建单体系统有助于控制未知的风险

任何关于如何开始微服务的书或文章，都会描述如何把一个现有系统拆解为组件服务的流程。但是你如果刚开始开发一个系统，没有现有系统进行拆解的话，想要在这个阶段就勾画出你所需要的需求（这些需求可以被拆分为接口定义良好的松耦合服务），是非常困难的。

### 2. 团队没准备好，那就考虑用单体架构

即使一个系统已经有了良好定义的功能，把它拆分成组件服务时也不是那么直接明了的。比如定义服务时，多小算是足够小了呢？通常的建议是逻辑上一个服务只做一件事，但是在这个快速发展，大数据的时代，太小可能牵连到性能。

这里主要的一点是有很多事需要做权衡以及团队需要正确的技能组。如果团队对微服务不熟悉，那么在培训上进行投资就很有必要。作者提到未受培训，早期就进行微服务开发的项目，后来都需要进行大量的重新开发。

### 3. 单体系统可能是让产品最快面世的方法，在很多情况下速度比完美的架构更重要

对于公司来说，特别是资金有限的创业公司，把东西卖出去是公司生存最重要的事。一个好的微服务是优美的，简单的，但是它不是很容易就得到的，也不是能迅速得到的，更不是偶然得到的。当今世界上有很多伟大的，成熟的，大规模的微服务例子，包括
Twitter, Amazon, Spotify, LinkedIn等等，他们都是从单体系统开始并慢慢演化成现在的样子。实用的架构意味着技术选择应该为商业需要服务，而不是反过来。

最后作者总结到，如果你要开发的系统功能足够清晰，团队也对微服务很熟悉，你的公司又有钱有时间能花在开发周期上，那么你绝对应在使用微服务架构来开发。反之，如果你还没有达到这几点，那也没关系。承认你目前的状态，规划前进的路线，有目的的迭代，你会不断改善你的处境，最后达到一个不管商业需求是什么你都能坦然应对的程度。


==================================================

在微服务大行其道的时代，作者从三个实用的角度触发，阐述了为何要使用单体系统。作者的观点，我非常赞同。我们使用技术是为了商业服务，技术只是实现目的的工具，而不是目的本身。因此我们要因地适宜的采用当下最合适自己的技术，而不能为了技术而采用不适合的技术，导致项目不能按时上线甚至于开发脱离自己的掌控而无法上线。


## Tip
### 教你一些IDEA中比较骚的操作技巧！

原为链接：[教你一些IDE中比较骚的操作技巧！](
https://mp.weixin.qq.com/s/tdAxAUSJCuUOvnJB4iOtWw)

IDEA是我非常喜欢的IDEA。最早使用Eclipse写Java，当时感觉Eclipse太好了，免费，功能强大，界面靠看，简直无任何毛病。因为觉得没毛病，所以写了好多年。直到后来因为什么原因已经不记得了，改用了一段时间的Intellij IDEA。用了以后，就再也回不到Eclipse了！

Intellij IDEA的确强大，主要是它的智能提示比Eclipse强太多了。写代码的效率无形中提高了好多。一般的快捷键，网上很多教程都有，但是这篇帖子提到的几个还真是第一次看到，而且非常使用。


## Share
### 互联网架构：屡试不爽的架构三马车

原文链接：[
互联网架构：屡试不爽的架构三马车](
https://mp.weixin.qq.com/s?__biz=MzIxMzEzMjM5NQ==&mid=2651031583&idx=1&sn=b80eb6e8240bd6dfc4fd3f23da29eba4)

这篇文章为互联网项目的架构提供了三个常用的利器：微服务，消息队列，定时任务。使用它们三个搭建的项目，不管项目大小如何，整个架构整体可扩展，可以在很长的一段时间内无需做大的调整。

![架构](
https://github.com/xuqingxin/arts/blob/master/images/Review2/architecture.webp)

### 微服务

一开始的时候就按照领域进行分割，能让我们对业务有更充分的理解，能让我们在之后的迭代中轻易在不同的业务模块上进行耕耘，能让我们的项目开发越来越轻松。轻松来源于几个方面：

1. 如果我们能进行微服务化，那么我们一定事先经过比较完善的产品需求讨论和领域划分，每一个服务精心设计自己领域内的表结构，这是一个很重要的设计过程，也决定了整个技术架构和产品架构是匹配的，对于All-In-One的架构往往会省略这一过程，需求到哪里代码写到哪里。
2. 我们对服务的划分和职责的定位如果是清晰的，对于新的需求，我们就能知道需要在哪里改怎么样的代码，没有复制粘贴的存在少了很多坑。
3. 我们大多数的业务逻辑已经开发完毕，直接重用即可，我们的新业务只是现有逻辑的聚合。
4. 在性能存在明显瓶颈的时候，我们可以针对性地对某些服务增加更多机器进行扩容，而且因为服务的划分，我们更清楚系统的瓶颈所在，从10000行代码定位到一行性能存在问题的代码是比较困难的，但是如果这10000行代码已经是由10个服务构成的，那么先定位到某个服务存在性能问题然后再针对这个服务进行分析一下子降低了定位问题的复杂度。
5. 如果业务有比较大的变动需要下线，那么我们可以肯定的是底层的公共服务是不会淘汰的，下线对应业务的聚合业务服务停掉流量入口，然后下线相关涉及到的基础服务进行部分接口即可。如果拥有完善的服务治理平台，整个操作甚至无需改动代码。

微服务设计需要遵循几个原则：

1. 服务的粒度划分需要把控好
2. 服务一定是立体的，不是在一个层次上的
3. 每一个服务对接的底层数据表是独立的没有交叉关联的，也就是数据结构是不直接对外的，需要使用其他服务的数据一定通过访问接口进行
4. 考虑到跨机器跨进程调用服务稳定性方面的显著差异
5. 考虑到跨机器跨进程调用服务数据传输方面的显著差异
6. 接口的粒度定义取决于使用者会怎么来使用数据，更趋向于一次使用单种类型数据还是复合类型的数据等等
7. 考虑接口升级的问题，接口的改动最好是兼容之前的接口，如果接口需要淘汰下线，需要先确保调用方改造到了新接口，确保调用方流量为0观察一段时间后方能从代码下线老接口
8. 在整个公司都搞起了微服务后，跨部门的一些服务调用在商定API的时候难免会有一些扯皮的现象发生，这个
有一些技术手段来化解的。
    > * 明确服务职责，也就明确了服务应该感知到什么不应该感知到什么
    > * 跨部门的服务交互的接口定义可以定的很轻，采用只有一个订单号的接口或MQ通知+数据回拉的策略（谁数据多谁提供数据接口，不用把数据一次性推给下游）
   > * 数据提供方可以构建一套通用数据接口，这样可以满足多个部门的需求，无需做定制化的处理。甚至在接口上可以提供落地和不落地两种性质的透传

### 消息队列

使用消息队列有几个好处：

1. 异步处理
2. 流量削峰
3. 模块解耦
4. 消息群发

在使用上有几个注意点：

1. 独立一个专门的listener项目（而不是合并在server中）来专门做消息的监听，然后这个模块其实没有过多的逻辑，只是在收到了具体的消息之后调用对应的service中的API进行消息处理。
2. 对于重要的MQ消息，应当配以相应的补偿线作为备份，在MQ集群一切正常作为补漏，在MQ集群瘫痪的时候作为后背。
3. 补偿的实现是不带任何业务逻辑的。
4. 所有消息的处理端最好对相同的消息处理实现幂等，即使有一些MQ产品支持消息处理且只处理一次，靠自己做好幂等能让事情变得更简单。
5. 有一些场景下有延迟消息或延迟消息队列的需求，诸如RabbitMQ、RocketMQ都有不同的实现方式。
6. MQ消息一般而言有两种，一种是（最好）只能被一个消费者进行消费并且只消费一次的，另一种是所有订阅者都可以来处理，不限制人数。不用的MQ中间件对于这两种形式都有不同的实现，有的时候使用消息类型来做，有的使用不同的交换机来做，有的是使用group的划分来做（不同的group可以重复消息相同的消息）。一般来说都是支持这两种实现的。在使用具体产品的时候务必研究相关的文档，做好实验确保这两种消息是以正确的方式在处理，以免发生妖怪问题。
7. 需要做好消息监控，最最重要的是监控消息是否有堆积，有的话需要及时增强下游处理能力（加机器，加线程），当然做的更好点可以以热点拓扑图绘制所有消息的流向流速一眼就可以看到目前哪些消息有压力。
8. 两个MQ集群，一套对内一套对外。

### 定时任务

定时任务的需求有那么几类：

1. 跨服务调用，MQ通知难免会有不可达的问题，我们需要有一定的机制进行补偿。
2. 有一些业务是基于任务表进行驱动的。
3. 有一些业务是定时定期来进行处理的，根本不需要实时进行处理（比如通知用户红包即将过期，和银行进行日终对账，给用户出账单等）。和2的区别在于，这里的任务的执行时间和频次是五花八门的，2的话一般而言是固定频次的。

定时任务设计需要遵循几个原则：

1. 任务可以由各种调度框架来驱动，比如ElasticJob、Quartz等等，需要独立项目处理，不能和服务混在一起，部署启动多份往往会有问题。
2. 任务项目只是一层皮，最多有一些配置的整合，不应该有实际的业务逻辑，不会触碰数据库，大部分情况就是在调用具体服务的API接口。Job项目就负责配置和频次的控制。
3. 补偿类的任务注意补偿次数，避免整个任务被死信数据卡住的问题。

最后，作者给出了使用这三大利器的一个项目框架结构。

* Site:
    * front
    * consoleapp-gateway
    * Façade
* Service:
    * partnerinvestservice-api
    * partnerinvestservice-server
    * partnerinvestservice-listener
    * normalinvestservice-api
    * normalinvestservice-server
    * normalinvestservice-listener
    * reserveinvestservice-api
    * reserveinvestservice-server
    * reserveinvestservice-listener
    * autoinvestservice-api
    * autoinvestservice-server
    * autoinvestservice-listener
* Business Service:
    * tradeservice-api
    * tradeservice-server
    * tradeservice-listener
    * loanservice-api
    * loanservice-server
    * loanservice-listener
    * userservice-api
    * userservice-server
    * projectservice-api
    * projectservice-server
    * accountservice-api
    * accountservice-server
    * accountservice-listener
    * activityservice-api
    * activityservice-server
    * activityservice-listener
    * vipservice-api
    * vipservice-server
    * vipservice-listener
* Foundation Service:
    * bankservice-api
    * bankservice-server
    * digsignservice-api
    * digsignservice-server
    * messageservice-api
    * messageservice-server
* Job:
    * scheduler-job
    * task-job
    * compensation-job

这每一个模块都可以打包成独立的包，所有的项目不一定都要在一个项目空间内，可以拆分为20个项目，服务的api+server+listener放在一个项目内，这样其实有利于CICD，缺点就是修改代码的时候需要打开N个项目。