# ARTS Week 5

## Algorithm
[ZigZag Conversion](https://github.com/xuqingxin/leetcode/blob/master/Algorithms/0006-ZigZag.Conversion.md)

## Review
### 为什么你需要学习Go语言？

原文链接：[Why should you learn Go?](
https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65)

这篇文章通过硬件和软件两个方面来说明Go语言出现的原因，并适时给出了Go语言的各个优势。

#### 硬件限制
2004年英特尔就推出了主频为3.0GHz的奔腾4处理器。不过如今Macbook Pro 2016的主频还是2.9GHz。在近10年里，硬件的处理能力并没有很大的进步。

通过硬件来提升性能，主要有几个方法：
* 给处理器增加越来越多的核。现在4核和8核是非常普遍的。
* 使用超线程
* 给处理器增加缓存

不过这几个方法都有各自的代价。由于存在物理极限，我们不可能无限制地增加内核。而缓存越大，它本身的速度也越慢。使用多核运行多线程会带来并发问题。

因此目前看来要走另一条路：通过更高效的软件来提升性能。

不幸的是，现代编程语言并没那么高效。

> ”现代处理器就像硝基燃料的有趣汽车，它们在四分之一英里的直线公路表现出色。 不幸的是，现代编程语言就像蒙特卡罗，它们充满了曲折和拐弯。“ —— [Davi Ungar](
https://en.wikipedia.org/wiki/David_Ungar)

既然要依靠软件来提高效率，而现代编程语言又没这个基因，那么就创造一个语言吧。

#### Go语言的协程
上面提到硬件制造商通过给处理器加入越来越多的内核来提高性能，那我们开发的软件和编程语言就应该很容易地支持并发，并且充分利用增加的内核，不需要因为内核数增加了而需要重写编写软件。

像Java，Python等绝大多数现代编程语言都是在90年代基于单线程的情况下创造出来的。它们支持多线程，但是会带来并发执行，线程锁定，竞争条件和死锁等一系列问题。它们使得使用这些语言进行多线程开发不是一件简单的事。

比如，Java开一线程需要大约1M内存。如果你开了上千个线程，那就会有很大内存压力，很容易因为内存不够而程序退出。另外在多个线程间通讯也是很困难的。

2009年Go语言发布的时候，多核处理器已经有了。Go语言用协程替代了线程。一个协程只会占用2K的内存，所以对于上G的内存的硬件来说，任何时候程序都可以保留有上百万的协程而不会崩溃。

协程的其他好处包括：
* 协程具有可增加的段堆栈，这意味着可以按需使用内存
* 协程有更快的启动时间
* 协程间有内建的基本类型进行安全通讯
* 协程在共享数据的时候，不需要使用Mutex，代价更小
* 协程和操作系统的线程之间不是一一映射关系。1个协程可以运行在多个线程上，多一个协程也可以共用几个线程。

Go语言在并发处理上，既有Java，C，C++的强大能力，又有Erlang一样优美的代码。
![Go吸收了两方面的有点，优雅的代码同时高效地执行](
https://github.com/xuqingxin/arts/blob/master/images/Review5/1.png)

#### Go直接运行在硬件之上
Java或者其他基于JVM的语言会先把代码编程成中间代码，然后由JVM或其他虚拟机把中间代码翻译成二进制指令，最后执行。这么做的好处是不需要自己管理内存的申请和释放，虚拟机会做这一步。
![基于虚拟机的执行步骤](
https://github.com/xuqingxin/arts/blob/master/images/Review5/2.png)

像C/C++等不基于虚拟机的语言，直接把代码翻译成立二进制指令，省去了中间的虚拟机这一步。这么做的好处是效率高，但是需要开发人员自己管理内存，而这往往是代码出错的高发原因。
![不基于虚拟机的执行步骤](
https://github.com/xuqingxin/arts/blob/master/images/Review5/3.png)

Go语言结合了两者的优势。既能像C/C++一样直接把代码编译成二进制指令，也实现了垃圾回收机制，开发人员不需要自己管理内存。

#### 使用Go语言编写的代码容易维护
Go语言有意去除了以下现代面向对象编程语言的特性。
* **没有类** 所有的东西都被分到了一个包里。Go语言只有结构而没有类。
* **不支持继承** 这会让代码很容易修改。像Java/Pyton这类编程语言，if 类ABC继承自类XYZ，而你又对类XYZ做了修改，那这些修改很有可能对所有继续自类XYZ的派生类产生副作用。通过去除了继承，Go语言也让理解代码变得更容易。
* 没有构造函数
* 没有注解
* 没有泛型
* 没有异常

![代码可读性和效率的对比](
https://github.com/xuqingxin/arts/blob/master/images/Review5/4.png)
如上图所示：Go语言在效率上跟C/C++一样高效，同时也保留了同Ruby，Python等语言一样的语法简洁性。对于人类和处理器来说，这是一个双赢的局面。

#### Go语言的背后是Google
* Go语言是由Google设计和支持的。Google是世界上最大的云计算基础设施供应商之一，它拥有超大规模的扩展能力。Go语言是Goolge为了解决支持扩展能力和效率这两个问题而设计的。

* 除了Google，其他大公司也在使用Go语言，像Adobe，BBC，IBM，Intel和Medium。([使用Go语言的公司列表](
https://github.com/golang/go/wiki/gousers))

#### 结论
* 即使Go语言同其他面向对象的语言有些区别，它仍然是非常棒的。Go语言提供了C/C++一样的高性能，Java一样超高效的并发处理能力，以及Python/Perl一样有意思的编码方式。

* 如果你没有学习Go语言的计划，我还是要说硬件限制把编写高效代码的压力转嫁到了软件开发人员身上。开发人员需要理解硬件并相应地优化它们的代码。优化过的软件可以跑在更便宜更慢的硬件设备上，但是总体上的用户体验却会更好。


## Tip
### MySQL中datetime与timestamp区别

#### datetime
1. 保存格式为yyyy-MM-dd HH:mm:ss.SSS（年月日时分秒毫秒），它与时区无关。MySQL 5.6.4后，可以存储小数，精确到毫秒；
2. 值范围：从1000-01-01 00:00:00.000 到 9999-12-31 23:59:59.999
3.  长度：8个字节
4.  格式：datetime(n)，n为小数位数。如果只需要精确到秒，使用datetime，或datetime(0)即可；如果需要精确到3为小数，则使用datetime(3)。

#### timestamp
1. 保存自1970-01-01午夜(格林尼治标准时间)以来的秒数，它和unix时间戳相同。它与时区有关，查询时转为相应的时区时间。比如，服务器上存储的是1970-01-01 00:00:00，客户端是北京，那么查询得到的结果会加8个时区的小时，即1970-01-01 08:00:00。
2. 值范围：1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07
3. 长度：4个字节
4. 格式：timestamp(n)，n为小数位数。如果只需要精确到秒，使用datetime，或datetime(0)即可；如果需要精确到3为小数，则使用datetime(3)。


## Share
### 架构师能力模型
原文链接：[架构师能力模型](https://mp.weixin.qq.com/s?__biz=MzI0MTczNDgyOQ==&mid=2247484195&idx=1&sn=4023a1def4da46509a481b77e297e1f7)

这篇文章归纳概括了架构师的主要能力：
* 研发流程的持续改进
* 归纳抽象和技术泛化能力
* 业务和需求的分析和理解能力
* 技术折中和持续改进能力
* 技术广度和深度
* 持续学习的能力
* 技术影响力
* 沟通表达能力
* 技术管理能力
* 坚持正确的价值观
